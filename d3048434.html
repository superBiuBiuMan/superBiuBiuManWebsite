<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>ts泛型,映射,条件类型和类型提取infer和一些常用工具库的说明 | 梦洁小站-属于你我的小天地</title><meta name="author" content="梦洁"><meta name="copyright" content="梦洁"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Typescript当中的T,K,V到底是个啥 有时候,我们看到下面的代码,当然,这里是简单例子来说  123function identity &lt;T&gt; (value:T) : T &#123;	return value;&#125;   其实泛型就是使用字母来代替将要接收的类型,这里的”T”是代表类型的缩写,表示对将要接收类型的一个占位符,占位符可以是任意字母,下面是一些常用的占位符"><meta property="og:type" content="article"><meta property="og:title" content="ts泛型,映射,条件类型和类型提取infer和一些常用工具库的说明"><meta property="og:url" content="https://www.dreamlove.top/d3048434.html"><meta property="og:site_name" content="梦洁小站-属于你我的小天地"><meta property="og:description" content="Typescript当中的T,K,V到底是个啥 有时候,我们看到下面的代码,当然,这里是简单例子来说  123function identity &lt;T&gt; (value:T) : T &#123;	return value;&#125;   其实泛型就是使用字母来代替将要接收的类型,这里的”T”是代表类型的缩写,表示对将要接收类型的一个占位符,占位符可以是任意字母,下面是一些常用的占位符"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101649725.png"><meta property="article:published_time" content="2022-11-20T20:27:02.000Z"><meta property="article:modified_time" content="2022-12-09T20:27:02.000Z"><meta property="article:author" content="梦洁"><meta property="article:tag" content="javascript"><meta property="article:tag" content="HTML"><meta property="article:tag" content="typescript"><meta property="article:tag" content="ts"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101649725.png"><link rel="shortcut icon" href="https://oss.ypggb.com/i/2025/07/01/pk26bw.png"><link rel="canonical" href="https://www.dreamlove.top/d3048434.html"><link rel="preconnect" href="https://lib.baomitu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/6.5.1/css/all.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancyapps-ui/5.0.33/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"G7A2D1SYPY",apiKey:"49056313a9be02852c7dbedfcb772831",indexName:"blog",hits:{per_page:20},languages:{input_placeholder:"搜索文章",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://lib.baomitu.com/egjs-infinitegrid/4.11.1/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"ts泛型,映射,条件类型和类型提取infer和一些常用工具库的说明",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-12-09 20:27:02"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach(e=>{n.setAttribute(e,t[e])}),document.head.appendChild(n)}),e.getCSS=(e,t=!1)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://oss.ypggb.com/i/2025/07/01/pk26bw.png" onerror='onerror=null,src="/img/404.png"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">101</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情和链接</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fas fa-link"></i><span> 链接导航</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 私有化导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://mark.123916.xyz/"><i class="fa-fw fas fa-database"></i><span> 导航</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://cloud.reassurehome.com/"><i class="fa-fw fas fa-hippo"></i><span> Alist(私有)</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://short.123916.xyz/027a2"><i class="fa-fw fas fa-paperclip"></i><span> clash免费订阅地址</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://short.123916.xyz/admin/"><i class="fa-fw fas fa-paperclip"></i><span> 短链接生成</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 好玩的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://make.girls.moe/#/"><i class="fa-fw fas fa-database"></i><span> 动漫头像制作</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://dfqshy.ysepan.com/"><i class="fa-fw fas fa-database"></i><span> FC游戏大全网盘</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.yikm.net/"><i class="fa-fw fas fa-database"></i><span> 小霸王</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.return8090.com/"><i class="fa-fw fas fa-database"></i><span> 小霸王(广告多)</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://farm.dreamlove.top"><i class="fa-fw fas fa-database"></i><span> QQ农场经典版</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://codepip.com/"><i class="fa-fw fas fa-database"></i><span> CssGame</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://photo.123916.xyz/"><i class="fa-fw fas fa-database"></i><span> 有趣的照片</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://buy.dreamlove.top/"><i class="fa-fw fas fa-heart"></i><span> 购物</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101649725.png)"><nav id="nav"><span id="blog-info"><a href="/" title="梦洁小站-属于你我的小天地"><span class="site-name">梦洁小站-属于你我的小天地</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情和链接</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fas fa-link"></i><span> 链接导航</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 私有化导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://mark.123916.xyz/"><i class="fa-fw fas fa-database"></i><span> 导航</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://cloud.reassurehome.com/"><i class="fa-fw fas fa-hippo"></i><span> Alist(私有)</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://short.123916.xyz/027a2"><i class="fa-fw fas fa-paperclip"></i><span> clash免费订阅地址</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://short.123916.xyz/admin/"><i class="fa-fw fas fa-paperclip"></i><span> 短链接生成</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 好玩的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://make.girls.moe/#/"><i class="fa-fw fas fa-database"></i><span> 动漫头像制作</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://dfqshy.ysepan.com/"><i class="fa-fw fas fa-database"></i><span> FC游戏大全网盘</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.yikm.net/"><i class="fa-fw fas fa-database"></i><span> 小霸王</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.return8090.com/"><i class="fa-fw fas fa-database"></i><span> 小霸王(广告多)</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://farm.dreamlove.top"><i class="fa-fw fas fa-database"></i><span> QQ农场经典版</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://codepip.com/"><i class="fa-fw fas fa-database"></i><span> CssGame</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://photo.123916.xyz/"><i class="fa-fw fas fa-database"></i><span> 有趣的照片</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://buy.dreamlove.top/"><i class="fa-fw fas fa-heart"></i><span> 购物</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ts泛型,映射,条件类型和类型提取infer和一些常用工具库的说明</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-20T20:27:02.000Z" title="发表于 2022-11-20 20:27:02">2022-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-09T20:27:02.000Z" title="更新于 2022-12-09 20:27:02">2022-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ts/">ts</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ts/typescript/">typescript</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ts/typescript/HTML/">HTML</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ts/typescript/HTML/javscript/">javscript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="ts泛型,映射,条件类型和类型提取infer和一些常用工具库的说明"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Typescript当中的T-K-V到底是个啥"><a href="#Typescript当中的T-K-V到底是个啥" class="headerlink" title="Typescript当中的T,K,V到底是个啥"></a>Typescript当中的T,K,V到底是个啥</h2><ul><li>有时候,我们看到下面的代码,当然,这里是简单例子来说</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity &lt;T&gt; (<span class="attr">value</span>:T) : T &#123;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>其实泛型就是使用字母来代替将要接收的类型,这里的”T”是代表类型的缩写,表示对将要接收类型的一个占位符,占位符可以是任意字母,下面是一些常用的占位符</p><ul><li><strong>T(Type)</strong> 表示类型</li><li><strong>K(Key)</strong> 表示对象中键的类型</li><li><strong>V(value)</strong> 表示对象中值的类型</li><li><strong>E(Element)</strong> 表示元素类型</li></ul></li><li><p>如果在函数中使用了泛型,那么我们可以在使用的时候指明类型,也可以不显式指明类型</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity &lt;T , U&gt;(<span class="attr">value</span>: T ,<span class="attr">message</span>: U) : T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不指定泛型变量的实际类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="number">20</span>,<span class="string">&#x27;动感超人&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动指定泛型变量的实际类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(identity&lt;<span class="built_in">number</span>,<span class="built_in">string</span>&gt;(<span class="number">20</span>,<span class="string">&#x27;动感超人&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h2><ul><li><p>假如我们在html当中引入了jquery插件,那么就会在全局当中增加一个关键字<code>$</code>,此时如果我们在ts文件当中的书写关键字<code>$</code></p></li><li><p>就会发现ts会提示<code>找不到$,ts2304</code>,也就是说<strong>ts不认识这个全局变量$</strong></p></li><li><p>所以我们可以使用<code>declare</code>来定义这个全局变量<code>declare const $ = xxxx</code>,这样子ts就认识这个全局变量$了</p></li><li><p><strong>注意点</strong></p><ul><li><code>declare</code>声明不包含具体的实现,也就是说我们只是声明,不做具体处理</li><li>declare可以定义全局变量,全局函数,全局枚举,全局类等</li><li>你看到的<strong>xxx.d.ts就是用于放置声明文件的</strong></li></ul></li><li><p>declare和一些声明文件查询:<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/dt/search?search=">@地址</a></p></li></ul><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul><li>为什么我们可以在ts中直接写<code>Math</code>,<code>JSON</code>,<code>Object</code>这些全局对象呢?那是英文typescript已经在文件当中声明了</li><li>在vie当中,我们可以在<code>node_modules/vite/client.d.ts</code>当中就可以看到declare的声明,部分代码如下</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.module.css&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">classes</span>: <span class="title class_">CSSModuleClasses</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> classes</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CSS</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.css&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">css</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> css</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// images</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.jpg&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">src</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>vite为什么要这样子做呢,因为如果它不这样子做,那么我们在使用下面代码就会报错</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果vite不declare,那么就会提示找不到模块&quot;./file.css&quot;/或其相应的类型声明</span></span><br><span class="line"><span class="keyword">import</span> css <span class="keyword">from</span> <span class="string">&quot;./file.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果vite不declare,那么就会提示找不到模块&quot;./abao.jpg&quot;或其相应的类型声明</span></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&quot;./abao.jpg&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>从ts2.0开始,declare支持通配符了,就如上声明一样使用了通配符</li></ul><h2 id="any类型和unknown类型"><a href="#any类型和unknown类型" class="headerlink" title="any类型和unknown类型"></a>any类型和unknown类型</h2><ul><li><p><code>any</code>:我不在乎它的类型</p></li><li><p><code>unknown</code>:我不知道它的类型(可以理解为类型安全的any),使用了unknown,<strong>必须要自己进行类型检测后才可以对变量进行操作,否则会报警告或错误</strong></p></li><li><p>对于下列函数,如果是使用<code>any</code>类型,是不会有任何报错提示的</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invokeCallBack</span>(<span class="params">callback:<span class="built_in">any</span></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">invokeCallBack</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>而对于我们使用了<code>unknown</code>,则会提示<code>TS2571: Object is of type &#39;unknown&#39;.</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invokeCallBack</span>(<span class="params">callback:<span class="built_in">unknown</span></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//TS2571: Object is of type &#x27;unknown&#x27;.</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">invokeCallBack</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>所以对于unknown来说,我们在使用前就必须要判断是否可以执行后才可以没有警告</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invokeCallBack</span>(<span class="params">callback:<span class="built_in">unknown</span></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            <span class="title function_">callback</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">invokeCallBack</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>需要注意的是,<strong>unknown类型的变量只可以赋值给unknown类型或者是any类型</strong></li></ul><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211191617954.png"></p><h2 id="typescript当中的类型"><a href="#typescript当中的类型" class="headerlink" title="typescript当中的类型"></a>typescript当中的类型</h2><ul><li><strong>never</strong>是空集,所以never类型无法被其他类型所赋值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Type &#x27;string&#x27; is not assignable to type &#x27;never&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">never</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Type &#x27;string&#x27; is not assignable to type &#x27;never&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">never</span> = <span class="string">&#x27;超人&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>接口定义对象类型,可以使用extends进行扩展</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Vector1D</span> &#123;<span class="attr">x</span>:<span class="built_in">number</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">	<span class="keyword">interface</span> <span class="title class_">Vector3D</span> &#123;</span><br><span class="line">		<span class="attr">x</span>:<span class="built_in">number</span>,</span><br><span class="line">		<span class="attr">y</span>:<span class="built_in">number</span>,</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vector2D</span> <span class="keyword">extends</span> <span class="title class_">Vector1D</span> &#123;<span class="attr">y</span>:<span class="built_in">number</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">	<span class="keyword">interface</span> <span class="title class_">Vector3D</span> &#123;</span><br><span class="line">		<span class="attr">x</span>:<span class="built_in">number</span>,</span><br><span class="line">		<span class="attr">y</span>:<span class="built_in">number</span>,</span><br><span class="line">		<span class="attr">z</span>:<span class="built_in">number</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vector3D</span> <span class="keyword">extends</span> <span class="title class_">Vector2</span>d &#123;<span class="attr">z</span>:<span class="built_in">number</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211191628471.png"></p><h2 id="type和interface的异同"><a href="#type和interface的异同" class="headerlink" title="type和interface的异同"></a>type和interface的异同</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="type-类型别名"><a href="#type-类型别名" class="headerlink" title="type 类型别名"></a>type 类型别名</h4><ul><li>针对基本类型和非对象类型的情况非常有用,支持泛型</li></ul><h4 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface 接口"></a>interface 接口</h4><ul><li>interface只能定义对象类型</li><li>定义接口类型时,可以同时声明对象身上的属性和方法</li></ul><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>类型别名和接口都可以用来描述对象或函数</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span>  = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetPoint</span> = <span class="function">(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>; <span class="comment">// &quot;;&quot; 或则 &quot;,&quot; 或者不写都可以</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SetPoint</span> &#123;</span><br><span class="line">  (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>类型别名和接口都支持扩展<ul><li>类型别名扩展使用<code>&amp;</code>交叉运算符进行合并运算,注意,交叉类型中的交叉,并不是指两个类型的交集,而是并集</li><li>接口扩展使用关键字<code>extends</code></li></ul></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名通过交叉运算符来扩展</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bear</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bear</span>: <span class="title class_">Bear</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;熊大&quot;</span>,</span><br><span class="line">  <span class="attr">honey</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口通过extends来扩展</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bear</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bear</span>: <span class="title class_">Bear</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;熊大&quot;</span>,</span><br><span class="line">  <span class="attr">honey</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>类型别名和接口都支持相互扩展,但需要注意的是接口只支持使用<code>extends</code>关键字来继承,类型也只支持使用<code>&amp;</code>来完成扩展</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bear</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bear</span>: <span class="title class_">Bear</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;熊大&quot;</span>,</span><br><span class="line">  <span class="attr">honey</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bear</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bear</span>: <span class="title class_">Bear</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;熊大&quot;</span>,</span><br><span class="line">  <span class="attr">honey</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>类型别名可以为基本类型,联合类型或元组类型定义别名,接口不行</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyNumber</span> = <span class="built_in">number</span>; <span class="comment">//基本类型定义别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumber</span> = <span class="built_in">string</span> | <span class="built_in">number</span>; <span class="comment">//联合类型定义别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>]; <span class="comment">//元组类型定义别名</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>同名接口会自动合并,而类型别名不会</strong></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;李白&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1000</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="property">name</span>; <span class="comment">//李白</span></span><br><span class="line">user.<span class="property">age</span>; <span class="comment">//1000</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//标识符“User”重复。ts(2300)</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="类型别名和接口的一些使用场景"><a href="#类型别名和接口的一些使用场景" class="headerlink" title="类型别名和接口的一些使用场景"></a>类型别名和接口的一些使用场景</h3><ul><li><p>使用类型别名的场景</p><ul><li>定义基本类型的别名时,使用type</li><li>定义元组类型时,使用type</li><li>定义函数类型时,使用type</li><li>定义联合类型时,使用type</li><li>定义映射类型时,使用type</li></ul></li><li><p>使用接口的场景</p><ul><li>需要利用接口自动合并特征的时候,使用interface</li><li>定义对象类型且无需使用type的时候,调用interface</li></ul></li></ul><h2 id="索引签名和Record内置工具类型"><a href="#索引签名和Record内置工具类型" class="headerlink" title="索引签名和Record内置工具类型"></a>索引签名和Record内置工具类型</h2><ul><li><p>有时候我们可能会想这样子,我想规定一个对象类型的key只能为字符串,值是任意的,那么要怎么做呢?可以使用索引签名</p></li><li><p><strong>格式语法如下</strong></p><ul><li><code>&#123;[key:KeyType] : ValueType&#125;</code></li><li><strong>key:</strong> 固定的写法</li><li>**keyType: ** key的类型,只支持<code>string</code>,<code>number</code>,<code>symbol</code>,不能为字面量类型或者是泛型类型,如需要使用字面量或泛型,则需要使用Record内置工具类型</li><li><strong>valueType:</strong> value的类型</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//比如下面</span></span><br><span class="line"><span class="keyword">interface</span> selfName1 &#123;</span><br><span class="line">    [<span class="attr">key</span>:<span class="built_in">string</span>] : <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">test1</span>:selfName1 = &#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&#x27;李白&#x27;</span>,</span><br><span class="line">   <span class="attr">hobby</span>:<span class="string">&#x27;吃饭&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">selfName2</span>:&#123;[<span class="attr">key</span>:<span class="built_in">string</span>] : <span class="built_in">string</span>&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;李白&#x27;</span>,</span><br><span class="line">    <span class="attr">hobby</span>:<span class="string">&#x27;吃饭&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">1000</span>,<span class="comment">//报错,警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要注意的是<code>KeyType</code>只能为<code>string</code> 或者 <code>number</code>或者<code>symbol</code>不能为其他的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的keyType</span></span><br><span class="line">interface selfName3 &#123;</span><br><span class="line">    <span class="comment">//keytype只能为string,number,symbol</span></span><br><span class="line">	[<span class="attr">key</span>:boolean] : string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用索引签名也可以和别的已知的key,value使用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Options</span> &#123;</span><br><span class="line">	[<span class="attr">key</span>:<span class="built_in">string</span>]:<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>,</span><br><span class="line">	<span class="attr">timeout</span>:<span class="built_in">number</span>,<span class="comment">//已知的键</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">option</span>:<span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">timeout</span>:<span class="number">1000</span>,</span><br><span class="line">    <span class="attr">errorMessae</span>:<span class="string">&#x27;The request timed out!&#x27;</span>,</span><br><span class="line">    <span class="attr">isSuccess</span>:<span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此外,索引签名也可以和模板字符串使用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PropChangeHandler</span> &#123;</span><br><span class="line">    [<span class="attr">key</span>:<span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>Changed`</span>]: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">handlers</span>:<span class="title class_">PropChangeHandler</span> = &#123;</span><br><span class="line">    <span class="attr">idChanged</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="attr">nameChanged</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//报错,因为后面少了一个字符&quot;d&quot;,和规定的type不相同</span></span><br><span class="line">    <span class="attr">ageChange</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Record内置工具类型和索引签名"><a href="#Record内置工具类型和索引签名" class="headerlink" title="Record内置工具类型和索引签名"></a>Record内置工具类型和索引签名</h3><ul><li>索引签名类型参数不能为字面量类型或者是泛型类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User1</span> = &#123;</span><br><span class="line">	<span class="comment">//报错 索引签名类型参数不能为字面量类型或者是泛型类型</span></span><br><span class="line">	[<span class="attr">key</span>:<span class="string">&quot;id&quot;</span>]:<span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User2</span> = &#123;</span><br><span class="line"><span class="comment">//报错 索引签名类型参数不能为字面量类型或者是泛型类型</span></span><br><span class="line">	[<span class="attr">key</span>:<span class="string">&quot;id&quot;</span> | <span class="string">&quot;name&quot;</span>] :<span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有人可能会有疑问,说,哎呀,这个为什么可以</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PropChangeHandler</span> &#123;</span><br><span class="line">    <span class="comment">//这个没问题,因为这个不是字面量啊</span></span><br><span class="line">    [<span class="attr">key</span>:<span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>Changed`</span>]: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而Record却可以包括字面量和泛型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User3</span> = <span class="title class_">Record</span>&lt;<span class="string">&quot;id&quot;</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="title class_">User3</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;2tjawjtiaowt&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User4</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;id&#x27;</span> | <span class="string">&#x27;name&#x27;</span>, <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">User4</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;2tjawjtiaowt&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;动感超人&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原来映射类型是这样子工作的"><a href="#原来映射类型是这样子工作的" class="headerlink" title="原来映射类型是这样子工作的"></a>原来映射类型是这样子工作的</h2><ul><li>ts的一些工具类型,比如说<code>Pick</code>,就是从某一个类型当中挑选一部分</li><li><strong>ts中的工具类型操作的是类型</strong>,而<strong>js当中工具类型操作的是值</strong>,</li><li>下面用ts的pick用js来做下解释,调用ts工具类型(类似函数)使用的是尖括号,js函数则是小括号(一句话,ts用尖括号,js用小括号)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//K extends T 泛型约束的语法,用于约束泛型K类型</span></span><br><span class="line">type <span class="title class_">Pick</span> &lt;T,K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">	[P <span class="keyword">in</span> K]:T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用js来解释就是</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Pick</span> (obj,keys) &#123;</span><br><span class="line">	<span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">of</span> keys)&#123;</span><br><span class="line">		result[key] = obj[key]<span class="string">&#x27;&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211191926111.gif" alt="动图"></p><h2 id="ts内置工具类型中的keyof操作符有啥用"><a href="#ts内置工具类型中的keyof操作符有啥用" class="headerlink" title="ts内置工具类型中的keyof操作符有啥用"></a>ts内置工具类型中的keyof操作符有啥用</h2><ul><li>首先来说下js当中的<code>Object.keys</code>函数作用,<code>Object.keys</code>会返回对象身上所有可枚举key组成的数组,数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;somestring&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(object1));</span><br><span class="line"><span class="comment">// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure><ul><li>那么ts当中的<code>keyof</code>也是,<strong>返回对象身上key值组成的联合类型</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">year</span>:number = <span class="number">2022</span>;</span><br><span class="line">    <span class="attr">hobby</span>:string = <span class="string">&#x27;吃饭&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于 type P0Types = &#x27;year&#x27; | &#x27;hobby&#x27;</span></span><br><span class="line">type P0Types = keyof <span class="title class_">Person</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">P01</span>:P0Types = <span class="string">&#x27;year&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">P02</span>:P0Types = <span class="string">&#x27;hobby&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Person1Inter</span> &#123;</span><br><span class="line">    <span class="attr">id</span>:number,</span><br><span class="line">    <span class="attr">name</span>:string,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于 type P1Types = &#x27;id&#x27; | &#x27;name&#x27; </span></span><br><span class="line">type P1Types = keyof <span class="title class_">Person1Inter</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">P11</span>:P1Types = <span class="string">&#x27;id&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">P12</span>:P1Types = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对枚举</span></span><br><span class="line">enum <span class="title class_">HttpMethods</span> &#123;</span><br><span class="line">    <span class="title class_">Get</span>,</span><br><span class="line">    <span class="title class_">Post</span>,</span><br><span class="line">&#125;</span><br><span class="line">type <span class="title class_">Methods</span> = keyof <span class="keyword">typeof</span> <span class="title class_">HttpMethods</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">P21</span>:<span class="title class_">Methods</span> = <span class="string">&#x27;Get&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">P22</span>:<span class="title class_">Methods</span> = <span class="string">&#x27;Post&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>对原始的数据类型也会获取到对应的联合类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">K1</span> = keyof <span class="built_in">boolean</span> ;<span class="comment">// ValueOf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot;</span></span><br><span class="line"><span class="comment">// | &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K2</span> = keyof <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K3</span> = keyof <span class="built_in">any</span>; <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span></span><br></pre></td></tr></table></figure><h2 id="ts为什么keyof-typeof可以拿到枚举的联合类型"><a href="#ts为什么keyof-typeof可以拿到枚举的联合类型" class="headerlink" title="ts为什么keyof typeof可以拿到枚举的联合类型 ?"></a>ts为什么keyof typeof可以拿到枚举的联合类型 ?</h2><ul><li>转载自<a target="_blank" rel="noopener" href="https://segmentfault.com/u/jamesfancy">@思否-边城</a></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> ab &#123;</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//uni等同于 &#x27;a&#x27; | &#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">type</span> uni = keyof <span class="keyword">typeof</span> ab</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TypeScript 中分“类型”和“值”，类型是 TypeScript 认的，一般编译后会消失（不存在于 JS 中）。枚举是比较特殊的定义，虽然定义成类型，但实际是值，它在编译成 JS 之后是一个对象。</p><p>TypeScript 中的枚举还分情况，有数值型枚举，也有字符串型枚举，还有混合型的……不讨论复杂了，这里就说数值型的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    A,</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X = keyof <span class="title class_">Hello</span>;</span><br></pre></td></tr></table></figure><p>你猜 <code>X</code> 是什么呢？你会发现它包含 <code>toFixed</code> 和 <code>toPrecision</code> 等，是不是感觉像是个 Number 类型的 Key 呢？</p><p>再来看看 Number 类型的 …… 果然一样</p><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211191912584.png"></p><blockquote><p>如果不加 <code>Exclude</code> 运算，会看到 <code>keyof Number</code> 看不到键列表</p></blockquote><p>想想，实际上也是，如果这样使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="title class_">Hello</span> = <span class="title class_">Hello</span>.<span class="property">A</span>;</span><br></pre></td></tr></table></figure><p><code>a</code> 的值实际上是一个 Number（仅数值型枚举的情况）</p><p>所以 TypeScript 中需要使用 <code>typeof Hello</code> 来取实际的枚举类型（不然就是 Number 的子类型），实际上它是一个接口。</p><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211191912868.png"></p><p>这个类型取出来之后，枚举值名称是被当作类型的 Key 的，所以可以用 <code>keyof</code> 把键值取出来。</p><h2 id="ts的映射和泛型"><a href="#ts的映射和泛型" class="headerlink" title="ts的映射和泛型"></a>ts的映射和泛型</h2><ul><li><p>ts的映射个人觉得有点像是js当中的map吧,操作都是传入a,经过处理后返回b</p></li><li><p>语法:</p><ul><li><code>&#123; [P in K]?:T &#125;</code></li></ul></li><li><p>一些工具库,比如说<code>Partial</code>,<code>Required</code>,<code>Pick</code>就是通过映射来实现的</p></li><li><p>比如现在有一个需求,需要把这个类型全部改为可选的,代码如下</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">	<span class="attr">password</span>: <span class="built_in">string</span>,</span><br><span class="line">	<span class="attr">address</span>: <span class="built_in">string</span>,</span><br><span class="line">	<span class="attr">phone</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//里面的属性需要全部改为可选的</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User1</span> = &#123;</span><br><span class="line">	name?:<span class="built_in">string</span>,</span><br><span class="line">	password?:<span class="built_in">string</span>,</span><br><span class="line">	address?:<span class="built_in">string</span>,</span><br><span class="line">	phone?:<span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//你可以使用工具库当中的Partial,也可以自己写一个~</span></span><br><span class="line"><span class="keyword">type</span> selfPartial&lt;T&gt; = &#123;</span><br><span class="line">	[K <span class="keyword">in</span> keyof T]?:T[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在映射的过程当中,可以通过添加<code>+</code>,<code>-</code>来添加.移除修饰符(+(加号为默认))<ul><li>没有添加前缀,默认使用加号</li></ul></li></ul><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211191939642.png" style="zoom:50%"> <img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211191938718.png" style="zoom:50%"><ul><li>映射类型示例</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Item</span> =</span><br><span class="line">&#123; <span class="attr">a</span>: <span class="built_in">string</span>; </span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>; </span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; x: number,y: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = &#123; [P <span class="keyword">in</span> <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>]: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123; x: &#x27;x&#x27;,y: &#x27;y &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = &#123; [P <span class="keyword">in</span> <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>]: P &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;a: string,b: number&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = &#123; [P <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>]: <span class="title class_">Item</span>[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;a: string,b: number,c: boolean&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = &#123; [P <span class="keyword">in</span> keyof <span class="title class_">Item</span>]: <span class="title class_">Item</span>[P] &#125;</span><br></pre></td></tr></table></figure><ul><li>映射演示</li></ul><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211191946273.gif" alt="映射演示"></p><h2 id="ts条件类型Conditional-Types"><a href="#ts条件类型Conditional-Types" class="headerlink" title="ts条件类型Conditional Types"></a>ts条件类型Conditional Types</h2><ul><li><p>ts的条件类型和js当中的三元运算符差不多</p></li><li><p>还是一句话,ts操作的是类型,js操作的是值</p></li><li><p><strong>语法</strong></p><ul><li><code>T extends U ? X : Y</code></li><li>T,U,X,Y都是类型占位符</li><li><strong>解释:当类型T可以赋值给类型U的时候,就返回X,否则就返回Y</strong></li></ul></li><li><p>先来看一个简单的例子</p><ul><li><code>type I2 = IsString&lt;any&gt;</code>:&#x2F;&#x2F;输出类型为boolean,是因为any这二个值都可以满足,所以就为boolean</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsString</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> :<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IsString</span>&lt;<span class="built_in">number</span>&gt;;<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IsString</span>&lt;<span class="string">&#x27;abc&#x27;</span>&gt;;<span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IsString</span>&lt;<span class="built_in">any</span>&gt;;<span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I3</span> = <span class="title class_">IsString</span>&lt;<span class="built_in">never</span>&gt;;<span class="comment">// never</span></span><br></pre></td></tr></table></figure><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211201749281.png"></p><h3 id="除了判断单一类型之外-利用条件类型和条件链-我们还可以同时判断多种类型"><a href="#除了判断单一类型之外-利用条件类型和条件链-我们还可以同时判断多种类型" class="headerlink" title="除了判断单一类型之外,利用条件类型和条件链,我们还可以同时判断多种类型"></a>除了判断单一类型之外,利用条件类型和条件链,我们还可以同时判断多种类型</h3><ul><li>当传入any的时候,会返回联合类型,因为都符合,所以在ts的三元是一直运算下去的</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; = </span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="attr">string</span>:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="attr">number</span>:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="attr">boolean</span>:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="attr">undefined</span>:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="title class_">Function</span>:</span><br><span class="line">    <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>&gt; <span class="comment">//string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">TypeName</span>&lt;<span class="string">&#x27;a&#x27;</span>&gt; <span class="comment">//string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">TypeName</span>&lt;<span class="literal">true</span>&gt; <span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">TypeName</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">//Function</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>[]&gt; <span class="comment">//Object</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">any</span>&gt;; <span class="comment">//string | number | boolean | Function | Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用js来书写上面的如下</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">…</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> condition1 ? value1</span><br><span class="line">         : condition2 ? value2</span><br><span class="line">         : condition3 ? value3</span><br><span class="line">         : value4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">…</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition1) &#123; <span class="keyword">return</span> value1; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123; <span class="keyword">return</span> value2; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition3) &#123; <span class="keyword">return</span> value3; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> value4; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果传入的是联合类型会发生什么结果"><a href="#如果传入的是联合类型会发生什么结果" class="headerlink" title="如果传入的是联合类型会发生什么结果"></a>如果传入的是联合类型会发生什么结果</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; = </span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="attr">string</span>:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="attr">number</span>:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="attr">boolean</span>:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="attr">undefined</span>:</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="title class_">Function</span>:</span><br><span class="line">    <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T10</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>)&gt;;<span class="comment">//string | Function</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T11</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">undefined</span>&gt;<span class="comment">//string | object | undefined</span></span><br></pre></td></tr></table></figure><ul><li>为什么T10 和 T11类型返回的是联合类型呢,因为TypeName属于分布式条件类型,在条件类型中,如果被检查的是一个”裸”类型参数,<strong>就是没有被数组,元组,或者Promise等包装过,则该条件类型被称为分布式条件类型</strong>,对于分布式条件类型来说,当传入的被检查类型是联合类型的时候,在运算过程中就会被依次运算</li></ul><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211201800719.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 裸类型</span></span><br><span class="line">type <span class="title class_">Naked</span>&lt;T&gt; = T <span class="keyword">extends</span> boolean ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line"><span class="comment">//分布式条件类型,判断每一个值是否都符合boolean</span></span><br><span class="line"><span class="comment">//是就为每一个值返回对应的结果</span></span><br><span class="line">type <span class="variable constant_">T0</span> = <span class="title class_">Naked</span>&lt;number | boolean&gt;;<span class="comment">// &quot;Y&quot; | &quot;N&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非裸类型</span></span><br><span class="line"><span class="comment">//判断传入的T当中的每一个值是否都符合boolean,是就只返回一个&quot;Y&quot;,否则只返回一个&quot;N&quot;</span></span><br><span class="line">type <span class="title class_">WrappedTuple</span>&lt;T&gt; = [T] <span class="keyword">extends</span> [boolean] ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断传入的T当中的每一个值为boolean类型的数组</span></span><br><span class="line">type <span class="title class_">WrappedArray</span>&lt;T&gt; = T[] <span class="keyword">extends</span> boolean[] ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line">type <span class="title class_">WrappedPromise</span>&lt;T&gt; = <span class="title class_">Promise</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;boolean&gt; ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line"></span><br><span class="line">type <span class="variable constant_">T1</span> = <span class="title class_">WrappedTuple</span>&lt;number | boolean&gt;;<span class="comment">// &quot;N&quot;</span></span><br><span class="line">type <span class="variable constant_">T2</span> = <span class="title class_">WrappedArray</span>&lt;number | boolean&gt;;<span class="comment">// &quot;N&quot;</span></span><br><span class="line">type <span class="variable constant_">T3</span> = <span class="title class_">WrappedPromise</span>&lt;number |boolean&gt;;<span class="comment">// &quot;N;</span></span><br><span class="line"></span><br><span class="line">type <span class="variable constant_">T4</span> = <span class="title class_">WrappedTuple</span>&lt;<span class="literal">true</span> | <span class="literal">false</span>&gt;;<span class="comment">// &quot;Y&quot;;</span></span><br><span class="line">type <span class="variable constant_">T5</span> = <span class="title class_">WrappedArray</span>&lt;<span class="literal">true</span> | <span class="literal">false</span>&gt;; <span class="comment">//&quot;Y&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>由以上结果可知，<strong>如果条件类型中的类型参数 T 被包装过</strong>，<strong>该条件类型就不属于分布式条件类型</strong>，<strong>所以在运算过程中就不会被分解成多个分支</strong>。<ul><li>说通俗点就是分布式条件运算返回值为联合类型,会对每一个值进行判断</li><li>非分布式条件运算就是对整体每一个值进行判断,返回值为普通的类型</li></ul></li></ul><h3 id="Exclude内置工具类型执行流程"><a href="#Exclude内置工具类型执行流程" class="headerlink" title="Exclude内置工具类型执行流程"></a>Exclude内置工具类型执行流程</h3><ul><li>ts内置工具类型<code>Exclude</code>作用是传入T,U,将这两个相同的值消除,不同的值提取(利用了条件类型)<ul><li>返回值为never代表抛弃</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T,U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回:c</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回:never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> ,<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure><p><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211201825303.webp" alt="Exclude演示"></p><h2 id="ts中的infer"><a href="#ts中的infer" class="headerlink" title="ts中的infer"></a>ts中的infer</h2><ul><li>现在有一个需求,获取数组当中的类型,和函数返回的类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求,获取数组的类型和返回值的类型要怎么做?</span></span><br><span class="line"><span class="comment">//做法如下,</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnpackedArray</span>&lt;T&gt; = T <span class="keyword">extends</span> (infer U)[] ? U : T;</span><br><span class="line"><span class="keyword">type</span> T0Result = <span class="title class_">UnpackedArray</span>&lt;<span class="variable constant_">T0</span>&gt;; <span class="comment">//string</span></span><br></pre></td></tr></table></figure><ul><li><p><code>infer</code><strong>是什么呢</strong>?</p><ul><li><code>T extends (infer U)[] ? U : T</code>:是条件类型的语法,而extends字句中的infer U 引入了一个新的类型变量U,用于存储被推断的类型,<strong>可以理解为后面这个U将用于存储类型</strong></li></ul></li><li><p><code>infer</code>注意的点?</p><ul><li><code>infer</code>只能在条件类型<code>extends</code>字句中使用,同时<code>infer</code>声明的类型变量只能在条件类型的true分支中可用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Wrong1</span>&lt;T <span class="keyword">extends</span> (infer U)[]&gt; = T[<span class="number">0</span>] <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Wrong2</span>&lt;T&gt; = (infer U)[] <span class="keyword">extends</span> T ? U : T <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Wrong3</span>&lt;T&gt; = T <span class="keyword">extends</span> (infer U)[] ? T : U <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211201840694.png" style="zoom:50%"></li><li><p>那么<code>infer</code>到底要怎么用呢?</p><ul><li>一句话:要判断的是什么样子,<code>infer</code>就长什么样子</li></ul></li><li><p>我们再来看看怎么判断函数的返回类型</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们接着来下面这个的返回值类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnpackedFunction</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>:<span class="built_in">any</span>[]) =&gt; (infer U) ? U : T;</span><br><span class="line"><span class="comment">//返回 string</span></span><br><span class="line"><span class="keyword">type</span> T1Types = <span class="title class_">UnpackedFunction</span>&lt;<span class="variable constant_">T1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Test</span> = <span class="title class_">UnpackedFunction</span>&lt;<span class="variable constant_">T0</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="当遇到函数重载的场景，TypeScript-将使用最后一个调用签名进行类型推断"><a href="#当遇到函数重载的场景，TypeScript-将使用最后一个调用签名进行类型推断" class="headerlink" title="当遇到函数重载的场景，TypeScript 将使用最后一个调用签名进行类型推断"></a>当遇到函数重载的场景，TypeScript 将使用最后一个调用签名进行类型推断</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x:<span class="built_in">string</span></span>):<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x:<span class="built_in">number</span></span>):<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x:<span class="built_in">string</span> | <span class="built_in">number</span></span>):<span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnpackedFn</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>:<span class="built_in">any</span>[]) =&gt; (infer U) ? U : T ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回:string | number;</span></span><br><span class="line"><span class="comment">//代表返回类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U2</span> = <span class="title class_">UnpackedFn</span>&lt;<span class="keyword">typeof</span> foo&gt;; </span><br></pre></td></tr></table></figure><h3 id="利用条件链我们可以实现功能更加强大的-Unpacked-工具类型。"><a href="#利用条件链我们可以实现功能更加强大的-Unpacked-工具类型。" class="headerlink" title="利用条件链我们可以实现功能更加强大的 Unpacked 工具类型。"></a>利用条件链我们可以实现功能更加强大的 Unpacked 工具类型。</h3><ul><li>还是那句话,使用<code>infer</code>,要判断的长什么样子,<code>infer</code>就长什么样子(括号包起来)</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Unpacked</span>&lt;T&gt; = </span><br><span class="line">    T <span class="keyword">extends</span> (...<span class="attr">args</span>:<span class="built_in">any</span>[]) =&gt; (infer U) ? U : </span><br><span class="line">    T <span class="keyword">extends</span> (infer U)[] ? U :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;(infer U)&gt; ? U : T;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">string</span>&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">string</span>[]&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Unpacked</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;[]&gt;;  <span class="comment">// Promise&lt;string&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Unpacked</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;[]&gt;&gt;;  <span class="comment">// string</span></span><br></pre></td></tr></table></figure><h3 id="利用条件类型和-infer，我们还可以推断出对象类型中键的类型"><a href="#利用条件类型和-infer，我们还可以推断出对象类型中键的类型" class="headerlink" title="利用条件类型和 infer，我们还可以推断出对象类型中键的类型"></a>利用条件类型和 infer，我们还可以推断出对象类型中键的类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PropertyType</span>&lt;T&gt;  = T <span class="keyword">extends</span> &#123;<span class="attr">id</span>: (infer U),<span class="attr">name</span>: (infer R) &#125; ? [U,R] : T;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U3</span> = <span class="title class_">PropertyType</span>&lt;<span class="title class_">User</span>&gt; <span class="comment">// [number, string]</span></span><br></pre></td></tr></table></figure><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211201855926.png" alt="推断类型-二个类型" style="zoom:50%"><ul><li>在 PropertyType 工具类型中，我们通过 infer 声明了两个类型变量 U 和 R，分别表示对象类型中 id 和 name 属性的类型。若类型配，我们就会<strong>以元组的形式返回 id 和 name 属性的类型</strong>。那么现在问题来了，在 PropertyType 工具类型中，<strong>如果只声明一个类型变量 U</strong>，那结果又会是怎样呢？下面我们来验证一下：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropertyType</span>&lt;T&gt; =  T <span class="keyword">extends</span> &#123; <span class="attr">id</span>: infer U, <span class="attr">name</span>: infer U &#125; ? U : T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U4</span> = <span class="title class_">PropertyType</span>&lt;<span class="title class_">User</span>&gt; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><ul><li>由以上代码可知，U4 类型返回的是 <strong>string 和 number 类型组合成的联合类型</strong>。为什么会返回这样的结果呢？这是因为在协变位置上，若同一个类型变量存在多个候选者，<strong>则最终的类型将被推断为联合类型</strong>。</li></ul><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211201856015.png" alt="推断类型-只有一个变量" style="zoom:50%"><ul><li>然而，在逆变位置上，若同一个类型变量存在多个候选者，则最终的类型将被推断为交叉类型。同样，我们来实际验证一下：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> tempType &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="function">(<span class="params">x:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="function">(<span class="params">x:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span>&lt;T&gt; = T <span class="keyword">extends</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="function">(<span class="params">x:infer U</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">        <span class="attr">b</span>:<span class="function">(<span class="params">x:infer U</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    &#125;</span><br><span class="line">    ? U : <span class="built_in">never</span>;</span><br><span class="line"><span class="comment">// string 和 number 类型组合成的交叉类型</span></span><br><span class="line"><span class="comment">// 即最终的类型是 never 类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U5</span> = <span class="title class_">Bar</span>&lt;tempType&gt;; <span class="comment">//string &amp; number 为never</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202211201902072.png" style="zoom:50%"><h2 id="ts的常用工具库"><a href="#ts的常用工具库" class="headerlink" title="ts的常用工具库"></a>ts的常用工具库</h2><p>@部分转载CSDN<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43869822">织_网</a></p><h4 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作用： Partial<t>;把T当中的所有属性都变为可选</t></p><p>详细：生成一个新类型，该类型与 T 拥有相同的属性，但是所有属性皆为可选项</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Foo</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">    name?: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h4><ul><li>源码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Required&lt;T&gt; = &#123;</span><br><span class="line">	[K in keyof T]-?:T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作用：Required<t>:将T所有属性变为必填的</t></p><p>详细：生成一个新类型，该类型与 T 拥有相同的属性，但是所有属性皆为必选项</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Required</span>&lt;<span class="title class_">Foo</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h4><ul><li>源码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Pick&lt;T,U extends keyof T&gt; = &#123;</span><br><span class="line">	[K in U]:T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作用：Pick(A,B);从A当中挑选B并返回</p><p>详细：生成一个新类型，该类型拥有 T 中的 K 属性集 ; <code>新类型 相当于 T 与 K 的交集</code></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">gender</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">gender</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">Bar</span>= &#123;</span><br><span class="line">   age?: <span class="number">3</span>,</span><br><span class="line">   <span class="attr">gender</span>: 男</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><ul><li>源码<ul><li><strong>分布式条件类型来说,当传入的被检查类型是联合类型的时候,在运算过程中就会被依次运算</strong></li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T,U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure><blockquote><p>作用：Exclude&lt;A,B&gt;; 排除A当中的B</p><p>详细： 如果 T 是 U 的子类型则返回 never 不是则返回 T(never可以理解为丢弃值不会返回)</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="title class_">Exclude</span>&lt;A, B&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span></span><br></pre></td></tr></table></figure><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T,U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><blockquote><p>作用：Extract&lt;A,B&gt; 从A中提取B</p><p>详细： 如果 T 是 U 的子类型则返回 T 不是则返回 never (never可以理解为丢弃值不会返回)</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="title class_">Extract</span>&lt;A, B&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br></pre></td></tr></table></figure><h4 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T,K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = <span class="title class_">Pick</span>&lt;T,<span class="title class_">Exclude</span>&lt;T,K&gt;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>作用：Exclude&lt;A,B&gt;; 排除A当中的B</p><p>详细： 如果 T 是 U 的子类型则返回 never 不是则返回 T(never可以理解为丢弃值不会返回)</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">	<span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;age&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure><blockquote><p>作用：NonNullable<t>;从T中排除null 和 undefined</t></p><p>详细： 从泛型 T 中排除掉 null 和 undefined</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t = <span class="title class_">NonNullable</span>&lt;<span class="string">&#x27;name&#x27;</span> | <span class="literal">undefined</span> | <span class="literal">null</span>&gt;;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="comment">// type t = &quot;name&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>:<span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; </span><br><span class="line">	= T <span class="keyword">extends</span> (...<span class="attr">args</span>:infer P) =&gt; <span class="built_in">any</span> ? <span class="attr">P</span>: <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><blockquote><p>作用：Parameters&lt; (形参) &#x3D;&gt; 返回值 &gt; 以元组的形式返回形参</p><p>详细： 以元组的方式获得函数的入参类型</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>&gt;; <span class="comment">// type t = [string]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="title class_">Parameters</span>&lt;(<span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>)  | (<span class="function">(<span class="params">age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">any</span>)&gt;; <span class="comment">// type t2 = [string] | [number]</span></span><br></pre></td></tr></table></figure><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>:<span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; </span><br><span class="line">    = </span><br><span class="line">    T <span class="keyword">extends</span> (...<span class="attr">arg</span>:<span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><blockquote><p>作用：ReturnType&lt; (形参) &#x3D;&gt; 返回值 &gt;</p><p>详细： 获得函数返回值的类型</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t = <span class="title class_">ReturnType</span>&lt;<span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="comment">// type t = string | number</span></span><br></pre></td></tr></table></figure><h4 id="Uppercase"><a href="#Uppercase" class="headerlink" title="Uppercase"></a>Uppercase</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Uppercase</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic</span><br></pre></td></tr></table></figure><blockquote><p>Uppercase<stringtype>将StringType转为大写，TS以内置关键字intrinsic来通过编译期来实现。</stringtype></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a = <span class="title class_">Uppercase</span>&lt;<span class="string">&#x27;abcDEF&#x27;</span>&gt;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">type</span> a = <span class="string">&#x27;ABCDEF&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="Lowercase"><a href="#Lowercase" class="headerlink" title="Lowercase"></a>Lowercase</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Lowercase</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br></pre></td></tr></table></figure><blockquote><p>Lowercase<stringtype>将StringType转为小写，TS以内置关键字intrinsic来通过编译期来实现。</stringtype></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a = <span class="title class_">Lowercase</span>&lt;<span class="string">&#x27;abcDEF&#x27;</span>&gt;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">type</span> a = <span class="string">&#x27;abcdef&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="Capitalize"><a href="#Capitalize" class="headerlink" title="Capitalize"></a>Capitalize</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Capitalize</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br></pre></td></tr></table></figure><blockquote><p>Capitalize<stringtype>将StringType首字母转为大写。</stringtype></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CapitalizeExample</span> = <span class="title class_">Capitalize</span>&lt;<span class="string">&quot;abc&quot;</span>&gt;;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CapitalizeExample</span> = <span class="string">&quot;Abc&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Uncapitalize"><a href="#Uncapitalize" class="headerlink" title="Uncapitalize"></a>Uncapitalize</h4><ul><li>源码</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Uncapitalize</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br></pre></td></tr></table></figure><blockquote><p>Uncapitalize<stringtype>将StringType首字母转为小写</stringtype></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a = <span class="title class_">Uncapitalize</span>&lt;<span class="string">&#x27;AbcDEF&#x27;</span>&gt;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">type</span> a = <span class="string">&#x27;abcDEF&#x27;</span>;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.dreamlove.top">梦洁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.dreamlove.top/d3048434.html">https://www.dreamlove.top/d3048434.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.dreamlove.top" target="_blank">梦洁小站-属于你我的小天地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javascript/">javascript</a><a class="post-meta__tags" href="/tags/HTML/">HTML</a><a class="post-meta__tags" href="/tags/typescript/">typescript</a><a class="post-meta__tags" href="/tags/ts/">ts</a></div><div class="post_share"><div class="social-share" data-image="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101649725.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://lib.baomitu.com/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/5dcd009d.html" title="使用backdrop-filter实现elementui官网的模糊滤镜效果的和毛玻璃效果"><img class="cover" src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101647316.png" onerror='onerror=null,src="/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用backdrop-filter实现elementui官网的模糊滤镜效果的和毛玻璃效果</div></div></a></div><div class="next-post pull-right"><a href="/5391ecf8.html" title="js的promise的究竟是同步还是异步的问题和promise.all可以同时请求多个接口是错误的回答的原因"><img class="cover" src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101653321.png" onerror='onerror=null,src="/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">js的promise的究竟是同步还是异步的问题和promise.all可以同时请求多个接口是错误的回答的原因</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/18c4d7af.html" title="油猴(篡改猴)学习记录"><img class="cover" src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202403181436823.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-27</div><div class="title">油猴(篡改猴)学习记录</div></div></a></div><div><a href="/e4e505ca.html" title="使用vite的社区模板来创建对应的项目(比如React17,vue+electron)"><img class="cover" src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101645867.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-06</div><div class="title">使用vite的社区模板来创建对应的项目(比如React17,vue+electron)</div></div></a></div><div><a href="/5391ecf8.html" title="js的promise的究竟是同步还是异步的问题和promise.all可以同时请求多个接口是错误的回答的原因"><img class="cover" src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101653321.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-19</div><div class="title">js的promise的究竟是同步还是异步的问题和promise.all可以同时请求多个接口是错误的回答的原因</div></div></a></div><div><a href="/5dcd009d.html" title="使用backdrop-filter实现elementui官网的模糊滤镜效果的和毛玻璃效果"><img class="cover" src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101647316.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="title">使用backdrop-filter实现elementui官网的模糊滤镜效果的和毛玻璃效果</div></div></a></div><div><a href="/8a2682cd.html" title="前端div水平居中的几种实现方式"><img class="cover" src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202403181421278.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-05</div><div class="title">前端div水平居中的几种实现方式</div></div></a></div><div><a href="/2cb9cb36.html" title="前端map标签(创建热点区域或是点击图片指定区域跳转对应链接))"><img class="cover" src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202403181443949.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">前端map标签(创建热点区域或是点击图片指定区域跳转对应链接))</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://oss.ypggb.com/i/2025/07/01/pk26bw.png" onerror='this.onerror=null,this.src="/img/404.png"' alt="avatar"></div><div class="author-info__name">梦洁</div><div class="author-info__description">小小的字,有大大的梦想~分享我的前端学习过程,经历,错误,和一些其他折腾过程</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">101</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/superBiuBiuMan"><i class="fab fa-github"></i><span>关注下我(*￣▽￣*)</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:zmqdream@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不断更新中,有问题请留言回复(会通过邮箱提醒~)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Typescript%E5%BD%93%E4%B8%AD%E7%9A%84T-K-V%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5"><span class="toc-number">1.</span> <span class="toc-text">Typescript当中的T,K,V到底是个啥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#declare"><span class="toc-number">2.</span> <span class="toc-text">declare</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%96%91%E9%97%AE"><span class="toc-number">2.1.</span> <span class="toc-text">疑问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any%E7%B1%BB%E5%9E%8B%E5%92%8Cunknown%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">any类型和unknown类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typescript%E5%BD%93%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">typescript当中的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type%E5%92%8Cinterface%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">5.</span> <span class="toc-text">type和interface的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#type-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">5.1.1.</span> <span class="toc-text">type 类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interface-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.2.</span> <span class="toc-text">interface 接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">5.2.</span> <span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text">不同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.4.</span> <span class="toc-text">类型别名和接口的一些使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D%E5%92%8CRecord%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">索引签名和Record内置工具类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Record%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">6.1.</span> <span class="toc-text">Record内置工具类型和索引签名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E6%9D%A5%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E5%AD%90%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">7.</span> <span class="toc-text">原来映射类型是这样子工作的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ts%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84keyof%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%9C%89%E5%95%A5%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">ts内置工具类型中的keyof操作符有啥用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ts%E4%B8%BA%E4%BB%80%E4%B9%88keyof-typeof%E5%8F%AF%E4%BB%A5%E6%8B%BF%E5%88%B0%E6%9E%9A%E4%B8%BE%E7%9A%84%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">ts为什么keyof typeof可以拿到枚举的联合类型 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ts%E7%9A%84%E6%98%A0%E5%B0%84%E5%92%8C%E6%B3%9B%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">ts的映射和泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ts%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8BConditional-Types"><span class="toc-number">11.</span> <span class="toc-text">ts条件类型Conditional Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E5%88%A4%E6%96%AD%E5%8D%95%E4%B8%80%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%A4%96-%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9D%A1%E4%BB%B6%E9%93%BE-%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%88%A4%E6%96%AD%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">除了判断单一类型之外,利用条件类型和条件链,我们还可以同时判断多种类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BC%A0%E5%85%A5%E7%9A%84%E6%98%AF%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C"><span class="toc-number">11.2.</span> <span class="toc-text">如果传入的是联合类型会发生什么结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exclude%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">11.3.</span> <span class="toc-text">Exclude内置工具类型执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ts%E4%B8%AD%E7%9A%84infer"><span class="toc-number">12.</span> <span class="toc-text">ts中的infer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E9%81%87%E5%88%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%8CTypeScript-%E5%B0%86%E4%BD%BF%E7%94%A8%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">12.1.</span> <span class="toc-text">当遇到函数重载的场景，TypeScript 将使用最后一个调用签名进行类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E9%93%BE%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84-Unpacked-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">12.2.</span> <span class="toc-text">利用条件链我们可以实现功能更加强大的 Unpacked 工具类型。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8C-infer%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%8E%A8%E6%96%AD%E5%87%BA%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%B8%AD%E9%94%AE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.3.</span> <span class="toc-text">利用条件类型和 infer，我们还可以推断出对象类型中键的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ts%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-number">13.</span> <span class="toc-text">ts的常用工具库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Partial"><span class="toc-number">13.0.1.</span> <span class="toc-text">Partial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Required"><span class="toc-number">13.0.2.</span> <span class="toc-text">Required</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pick"><span class="toc-number">13.0.3.</span> <span class="toc-text">Pick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exclude"><span class="toc-number">13.0.4.</span> <span class="toc-text">Exclude</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extract"><span class="toc-number">13.0.5.</span> <span class="toc-text">Extract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Omit"><span class="toc-number">13.0.6.</span> <span class="toc-text">Omit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NonNullable"><span class="toc-number">13.0.7.</span> <span class="toc-text">NonNullable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parameters"><span class="toc-number">13.0.8.</span> <span class="toc-text">Parameters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReturnType"><span class="toc-number">13.0.9.</span> <span class="toc-text">ReturnType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Uppercase"><span class="toc-number">13.0.10.</span> <span class="toc-text">Uppercase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lowercase"><span class="toc-number">13.0.11.</span> <span class="toc-text">Lowercase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Capitalize"><span class="toc-number">13.0.12.</span> <span class="toc-text">Capitalize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Uncapitalize"><span class="toc-number">13.0.13.</span> <span class="toc-text">Uncapitalize</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/31d04109.html" title="java枚举和mybaits-plus结合实现映射输出和存储">java枚举和mybaits-plus结合实现映射输出和存储</a><time datetime="2025-05-26T20:23:14.000Z" title="发表于 2025-05-26 20:23:14">2025-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dc4ed705.html" title="qq农场,牧场解包查看导出swf文件内容图片"><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202503251433885.png" onerror='this.onerror=null,this.src="/img/404.png"' alt="qq农场,牧场解包查看导出swf文件内容图片"></a><div class="content"><a class="title" href="/dc4ed705.html" title="qq农场,牧场解包查看导出swf文件内容图片">qq农场,牧场解包查看导出swf文件内容图片</a><time datetime="2025-03-25T14:28:01.000Z" title="发表于 2025-03-25 14:28:01">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ed2e6c27.html" title="移动云盘加密分析-以链接有消息检查为例子"><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202503251433302.png" onerror='this.onerror=null,this.src="/img/404.png"' alt="移动云盘加密分析-以链接有消息检查为例子"></a><div class="content"><a class="title" href="/ed2e6c27.html" title="移动云盘加密分析-以链接有消息检查为例子">移动云盘加密分析-以链接有消息检查为例子</a><time datetime="2025-03-22T12:24:10.000Z" title="发表于 2025-03-22 12:24:10">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3cde95bc.html" title="mstsc使用proxifier走clash代理降低延迟"><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202503030912164.png" onerror='this.onerror=null,this.src="/img/404.png"' alt="mstsc使用proxifier走clash代理降低延迟"></a><div class="content"><a class="title" href="/3cde95bc.html" title="mstsc使用proxifier走clash代理降低延迟">mstsc使用proxifier走clash代理降低延迟</a><time datetime="2025-03-03T09:11:01.000Z" title="发表于 2025-03-03 09:11:01">2025-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d6a2907d.html" title="适配FASTGPT基础AI模板-适合对付领导突发AI-奇想而生的模板"><img src="https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202502201550402.png" onerror='this.onerror=null,this.src="/img/404.png"' alt="适配FASTGPT基础AI模板-适合对付领导突发AI-奇想而生的模板"></a><div class="content"><a class="title" href="/d6a2907d.html" title="适配FASTGPT基础AI模板-适合对付领导突发AI-奇想而生的模板">适配FASTGPT基础AI模板-适合对付领导突发AI-奇想而生的模板</a><time datetime="2025-02-20T15:45:25.000Z" title="发表于 2025-02-20 15:45:25">2025-02-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://dreamos.oss-cn-beijing.aliyuncs.com/gitblog/202304101649725.png)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By 梦洁</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://lib.baomitu.com/fancyapps-ui/5.0.33/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{let t=null;const e=()=>{if(t=Artalk.init(Object.assign({el:"#artalk-wrap",server:"https://artalk.dreamlove.top",site:"梦洁小站",pageKey:location.pathname,darkMode:"dark"===document.documentElement.getAttribute("data-theme")},null)),"null"===GLOBAL_CONFIG.lightbox)return;t.on("list-loaded",()=>{t.ctx.get("list").getCommentNodes().forEach(t=>{const e=t.getRender().$content;btf.loadLightbox(e.querySelectorAll("img:not([atk-emoticon])"))})});btf.addGlobalFn("pjax",()=>{t.destroy()},"destroyArtalk")},a=async()=>{"object"==typeof Artalk||(await getCSS("https://lib.baomitu.com/artalk/2.8.2/Artalk.min.css"),await getScript("https://lib.baomitu.com/artalk/2.8.2/Artalk.min.js")),e()};btf.addGlobalFn("themeChange",e=>{const a=document.getElementById("artalk-wrap");if(!a||!a.children.length)return;const l="dark"===e;t.setDarkMode(l)},"artalk"),a()})()</script></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://lib.baomitu.com/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://lib.baomitu.com/algoliasearch/4.22.1/algoliasearch-lite.umd.min.js"></script><script src="https://lib.baomitu.com/instantsearch.js/4.65.0/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>